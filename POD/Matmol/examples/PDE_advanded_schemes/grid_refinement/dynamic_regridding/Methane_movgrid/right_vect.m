%... The MatMol Group (2016)
%... %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%... % compute the right vector of the global ODEs system %
%... %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%...
%... The following code implements the right vector b(x,t) of the system
%...
%...            A(x,t)xdot = b(x,t)
%...
%... with
%...          1   2         ne      1   2         ne            1         ne
%...    x = [u   u   ...   u   z   u   u   ...   u   z   ...   u   ...   u   z ]'
%...          1   1         1   1   2   2         2   2         n         n   n
%...
%... and where the meshpoints 1, 2, ... n are the interiors nodes. Nevertheless, b(x,t) uses also
%...
%... the boundary points and values z , z   , u  , u   .
%...                                 0   n+1   0    n+1
%...
%... The code first implements the boundary conditions and computes the monitor function.
%...
%... Then, following elements of b(x,t) are then implemented :
%...
%...    a) elements from the moving grid equation :
%...
%...            1         mu        1+2mu       mu          1         mu        1+2mu       mu
%...    g(i) = --- [ - --------- + ------- - -------- ] - ----- [ - ------- + --------- - -------- ]
%...           M(i)    dltz(i+1)   dltz(i)   dltz(i-1)    M(i-1)    dltz(i)   dltz(i-1)   dltz(i-2)
%...
%...    b) elements from the PDEs :
%...
%...    udot(i,j)   i = 1, ..., n       j = 1, ..., ne.
%...
%... Structure of b(x,t) : b(x,t) is (ne+1)*n vector :
%...
%...                udot(1,1)
%...
%...                udot(1,2)
%...
%...                . . .
%...
%...                udot(1,ne)
%...
%...                g(1)
%...
%...                udot(2,1)
%...
%...                udot(2,2)
%...
%...                . . .
%...    b(x,t) =
%...                udot(2,ne)
%...
%...                g(2)
%...
%...                . . . . . . . .
%...
%...                udot(n,1)
%...
%...                udot(n,2)
%...
%...                . . .
%...
%...                udot(n,ne)
%...
%...                g(n)
%...
%...
     function xt = right_vect(t,x)
%...
     global zL zR n ne
     global alpha kappa mu tau
     global u z dltz
     global Deff rhocp rhog cpg Tw Eact DHM lamb v0 eps kw Rt Kr Kc R;
     global choice
%...     
%     t
%...
%... separate dependent variables and node positions and implement the BCs
%...
     [u z] = Bcintroduct(t,x);
%...
%... Compute the monitoring function mon(i)
%...
     mon = monitor(u,z,choice,t);
%...
%... compute the right vector g(n) of the moving grid equation
%...
     g = rightmon(mon,dltz,mu);
%...
%...
%... compute the right member of the pdes
%...
%... select finite difference (FD) approximation of the spatial
%... derivative
%...
     v = 1;
     D1=five_point_biased_upwind_D1(z,v);
     D2=five_point_centered_D2(z);
%...
%... spatial derivatives
%...
     uz=D1*u;
     uzz=D2*u;
%...
%... temporal derivatives
%...
     udot(:,1) = Deff*uzz(:,1) - v0*uz(:,1) - r(u(:,1),u(:,2));
     udot(:,2) = (lamb/rhocp)*uzz(:,2) - (eps*v0*rhog*cpg/rhocp)*uz(:,2)...
               + (2*kw/(Rt*rhocp))*(Tw*ones(n+2,1)-u(:,2)) + (DHM/rhocp)*r(u(:,1),u(:,2));
%...
%... assemble the global right vector
%...
     for j=1:ne,
         xt(j:ne+1:n*(ne+1),1)=udot(2:n+1,j);
     end
     xt(ne+1:ne+1:n*(ne+1),1)=g; 
%...

     function source = r(c,T)
     global Eact R Kr Kc;
     source = Kr*(c.*exp(-Eact./(R*T)))./(1+Kc*c);
